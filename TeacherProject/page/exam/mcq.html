<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="page-title">Pareeksha - MCQ Exam Setup</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- Base Variables & Reset (From Original) --- */
        :root {
            --bg-color: #f8fafc;
            --card-bg: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --primary-accent: #334155;
            --primary-accent-hover: #1e293b;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            line-height: 1.6;
        }

        h2 { font-size: 1.75rem; font-weight: 700; margin-bottom: 1.5rem; }
        h3 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; }

        /* --- Header (From Original) --- */
        header {
            background-color: var(--card-bg);
            padding: 1rem 2rem;
            box-shadow: var(--shadow-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
        }
        .header-left {
            display: flex;
            align-items: center;
            gap: 2rem;
        }
        .header-title { font-size: 1.25rem; font-weight: 600; }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .back-link {
            color: var(--text-secondary);
            text-decoration: none;
            font-size: 0.9rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            transition: color 0.2s;
        }
        .back-link:hover {
            color: var(--text-primary);
        }
        .time-input-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .time-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .time-group label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }
        .time-group input {
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 500;
            width: 60px;
            text-align: right;
            -moz-appearance: textfield;
        }
        .time-group input::-webkit-outer-spin-button,
        .time-group input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* --- Layout (Modified) --- */
        .container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 6.5rem 2rem 2rem;
        }
        .grid-layout {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
        }

        /* --- Components (From Original) --- */
        .card {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
            margin-bottom: 2rem; /* Add spacing between question cards */
        }
        .card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        .card.highlight {
            border-left: 5px solid var(--primary-accent);
        }
        
        .main-action-btn {
            width: auto;
            background-color: var(--primary-accent);
            color: white;
            font-weight: 600;
            padding: 0.85rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .main-action-btn:hover {
            background-color: var(--primary-accent-hover);
        }
        .main-action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .header .main-action-btn {
            width: auto;
            margin-top: 0;
            padding: 0.5rem 1rem;
        }

        /* Form Controls (From Original) */
        .form-control-group {
            margin-bottom: 1.5rem;
        }
        .form-label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
        }
        .input-text, select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 1rem;
            color: var(--text-primary);
            background-color: var(--bg-color);
            transition: border-color 0.2s;
        }
        .input-text:focus, select:focus {
            outline: none;
            border-color: var(--primary-accent);
        }

        /* Error Styles (From Original) */
        .input-error {
            border: 2px solid #ef4444 !important;
            animation: shake 0.3s;
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            20%, 60% { transform: translateX(-5px); }
            40%, 80% { transform: translateX(5px); }
        }
        
        /* Custom styles for the Console Terminal */
        #test-output-console {
            min-height: 50px; 
            background-color: #f3f4f6; 
            color: #1e293b;
            white-space: pre-wrap;
            word-wrap: break-word;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
        }
        
        /* --- MCQ Specific Styles (New) --- */
        .options-container {
            margin-top: 1rem;
        }
        .option-group {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 0.75rem;
        }
        .option-group .input-text {
            flex-grow: 1;
        }
        .remove-option-btn, .remove-question-btn {
            background-color: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-weight: 700;
            transition: background-color 0.2s;
            flex-shrink: 0;
        }
        .remove-option-btn:hover, .remove-question-btn:hover {
            background-color: #dc2626;
        }
        .add-option-btn {
            background-color: #10b981;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-weight: 600;
            margin-top: 1rem;
            transition: background-color 0.2s;
        }
        .add-option-btn:hover {
            background-color: #059669;
        }
        .correct-answer-radio {
            margin-left: 0.5rem;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .marks-display {
            font-size: 1.1rem;
            font-weight: 600;
            color: #334155;
            margin-top: 1.5rem;
        }

        /* --- Footer Action Button --- */
        #add-question-btn {
            background-color: #3b82f6;
            color: white;
            font-weight: 600;
            padding: 1rem 2rem;
            border-radius: 0.75rem;
            border: none;
            cursor: pointer;
            font-size: 1.1rem;
            width: 100%;
            margin-bottom: 1rem;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        #add-question-btn:hover {
            background-color: #2563eb;
        }

    </style>
</head>
<body>
    <header>
        <div class="header-left">
            <a href="../add_new.html" id="back-to-add-new" class="back-link">
                <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                    <path d="M19 12H5M12 19l-7-7 7-7"></path>
                </svg>
                Back to Exam Details
            </a>
            <div class="header-title" id="mode-title">Pareeksha MCQ Exam Setup</div>
        </div>
        <div class="header-controls">
             <div class="time-input-container">
                <div class="time-group">
                    <label for="exam-duration-hours">Duration (Hrs)*</label>
                    <input type="number" id="exam-duration-hours" min="0" max="10" value="0">
                </div>
                <div class="time-group">
                    <label for="exam-duration-minutes">Duration (Mins)*</label>
                    <input type="number" id="exam-duration-minutes" min="0" max="59" value="30">
                </div>
            </div>
            <button id="save-finish-btn" class="main-action-btn">
                Finalize & Submit Exam
                <svg width="20" height="20" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" style="margin-left: 0.5rem;">
                    <path d="M5 13l4 4L19 7"></path>
                </svg>
            </button>
        </div>
    </header>

    <div class="container">
        
        <div id="questions-list">
            </div>

        <button id="add-question-btn">
            <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                <path d="M12 5v14M5 12h14"></path>
            </svg>
            Add New Question
        </button>

        <div class="card" style="margin-top: 2rem;">
            <h3>Exam Status & Console</h3>
            <div class="marks-display" id="marks-summary">Total Questions: 0 | Mark per Question: 0 | Total Marks: 0 / 50</div>
            <p class="text-sm text-gray-500 mt-2">All questions will be automatically assigned marks to sum up to 50.</p>
            <pre id="test-output-console" style="margin-top: 1rem;">Initializing. Ready to create a new MCQ exam...</pre>
        </div>
    </div>

    <script type="module">
        import { db, collection, addDoc, doc, getDoc, setDoc, deleteDoc, query, orderBy, getDocs, serverTimestamp } from '../../firebase-init.js'; 

        // --- DOM Elements ---
        const examDurationHours = document.getElementById('exam-duration-hours');
        const examDurationMinutes = document.getElementById('exam-duration-minutes');
        const saveFinishBtn = document.getElementById('save-finish-btn');
        const addQuestionBtn = document.getElementById('add-question-btn');
        const questionsList = document.getElementById('questions-list');
        const marksSummary = document.getElementById('marks-summary');
        const testOutputConsole = document.getElementById('test-output-console');
        const modeTitle = document.getElementById('mode-title');
        const backToAddNewLink = document.getElementById('back-to-add-new');

        // --- CONSTANTS & STATE ---
        const TOTAL_EXAM_MARKS = 50;
        let questionCounter = 0;
        let questionsData = []; 
        
        function getParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                examId: params.get('id'),
                isNew: params.get('new') === 'true'
            };
        }
        const { examId: EXAM_ID, isNew: IS_NEW_EXAM } = getParams();

        let hasQuestionsSaved = false; // Flag to prevent deleting valid exams


        // --- Console and Visual Feedback ---
        function updateConsole(message, type = 'info') {
            let bgColor = '#f3f4f6';
            let textColor = '#1e293b';

            if (type === 'error') {
                bgColor = '#fef2f2';
                textColor = '#ef4444';
            } else if (type === 'success') {
                bgColor = '#ecfdf5';
                textColor = '#059669';
            } else if (type === 'warning') {
                bgColor = '#fffbe5';
                textColor = '#f59e0b';
            }
            
            testOutputConsole.textContent = message;
            testOutputConsole.style.backgroundColor = bgColor;
            testOutputConsole.style.color = textColor;
        }

        function flashError(element) {
            if (element) {
                element.classList.add('input-error');
                element.focus();
                element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                setTimeout(() => {
                    element.classList.remove('input-error');
                }, 1000);
            }
        }
        
        // --- DELETE FUNCTION FOR UNSAVED EXAMS ---
        function attemptCleanup() {
            if (EXAM_ID && IS_NEW_EXAM && !hasQuestionsSaved) {
                // Perform cleanup only if:
                // 1. We have an exam ID.
                // 2. It was flagged as new by add_new.html.
                // 3. No question has been successfully saved yet.
                console.log(`[CLEANUP] Attempting to delete unsaved exam: ${EXAM_ID}`);
                const examDocRef = doc(db, 'exams', EXAM_ID);
                deleteDoc(examDocRef)
                    .then(() => console.log(`[CLEANUP SUCCESS] Exam ${EXAM_ID} deleted.`))
                    .catch(err => console.error(`[CLEANUP FAILED] Could not delete exam ${EXAM_ID}:`, err));
            }
        }
        
        // --- Question Data Management ---

        function calculateMarks() {
            // Recalculates based on the current questionsData array length
            const numQuestions = questionsData.length;
            if (numQuestions === 0) {
                marksSummary.textContent = `Total Questions: 0 | Mark per Question: 0 | Total Marks: 0 / ${TOTAL_EXAM_MARKS}`;
                return 0;
            }
            const markPerQuestion = TOTAL_EXAM_MARKS / numQuestions;
            marksSummary.textContent = `Total Questions: ${numQuestions} | Mark per Question: ${markPerQuestion.toFixed(2)} | Total Marks: ${TOTAL_EXAM_MARKS} / ${TOTAL_EXAM_MARKS}`;
            return markPerQuestion;
        }

        function createOptionElement(qIndex, optionText = '', isCorrect = false) {
            const optionIndex = questionsData[qIndex].options.length;
            const optionId = `q${qIndex}-opt${optionIndex}`;
            
            const div = document.createElement('div');
            div.className = 'option-group';
            div.innerHTML = `
                <input type="text" id="${optionId}" class="input-text option-text" placeholder="Enter option text" value="${optionText}" required>
                <input type="radio" name="correct-option-${qIndex}" class="correct-answer-radio" value="${optionIndex}" ${isCorrect ? 'checked' : ''}>
                <button type="button" class="remove-option-btn">
                    <svg width="18" height="18" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                        <path d="M18 6L6 18M6 6l12 12"></path>
                    </svg>
                </button>
            `;
            
            // Add initial option data to array
            questionsData[qIndex].options.push({ text: optionText, isCorrect: isCorrect });

            // Event listeners (re-synced after options array is rebuilt during removal)
            div.querySelector('.remove-option-btn').onclick = function() { removeOption(qIndex, div); };
            div.querySelector('.option-text').oninput = function(e) { updateOptionText(qIndex, div, e.target.value); };
            div.querySelector('.correct-answer-radio').onchange = function(e) { updateCorrectAnswer(qIndex, div, parseInt(e.target.value)); };

            return div;
        }
        
        function removeOption(qIndex, optionDiv) {
            const optionsContainer = optionDiv.parentElement;
            const indexToRemove = Array.from(optionsContainer.children).indexOf(optionDiv);

            if (indexToRemove > -1) {
                // Remove from DOM
                optionsContainer.removeChild(optionDiv);

                // Remove from state array
                questionsData[qIndex].options.splice(indexToRemove, 1);
                
                // Re-sync radio button values after removal
                optionsContainer.querySelectorAll('.option-group').forEach((group, newIndex) => {
                    const radio = group.querySelector('.correct-answer-radio');
                    radio.value = newIndex;
                    
                    if(questionsData[qIndex].correctAnswerIndex === indexToRemove) {
                        questionsData[qIndex].correctAnswerIndex = -1; // Flag as missing
                    } else if (questionsData[qIndex].correctAnswerIndex > indexToRemove) {
                        questionsData[qIndex].correctAnswerIndex--; // Decrement index if it was after the removed one
                    }
                });
            }
            updateConsole('Option removed. Don\'t forget to set the correct answer!');
        }

        function updateOptionText(qIndex, optionDiv, newText) {
            const indexToUpdate = Array.from(optionDiv.parentElement.children).indexOf(optionDiv);
            questionsData[qIndex].options[indexToUpdate].text = newText;
        }

        function updateCorrectAnswer(qIndex, optionDiv, newIndex) {
            questionsData[qIndex].correctAnswerIndex = newIndex;
            updateConsole(`Correct Answer set for Q${qIndex + 1} to Option ${String.fromCharCode(65 + newIndex)}`);
        }

        function addQuestionCard(existingData = null) {
            const qIndex = questionCounter++;
            
            // Initialize data in state array
            questionsData.push({
                id: existingData?.id || `new_q${qIndex}`,
                title: existingData?.title || `Question ${qIndex + 1}`,
                options: [], // Options array populated by createOptionElement
                correctAnswerIndex: existingData?.correctAnswerIndex !== undefined ? existingData.correctAnswerIndex : -1,
                mark: 0 
            });

            const card = document.createElement('div');
            card.className = 'card highlight question-card';
            card.setAttribute('data-q-index', qIndex);
            
            card.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
                    <h2>Question ${qIndex + 1}</h2>
                    <button type="button" class="remove-question-btn">
                         <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                            <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"></path>
                        </svg>
                    </button>
                </div>

                <div class="form-control-group">
                    <label class="form-label" for="question-title-${qIndex}">Question Text *</label>
                    <textarea id="question-title-${qIndex}" class="input-text question-text-area" rows="3" placeholder="Enter the question text here..." required>${existingData?.title || ''}</textarea>
                </div>
                
                <h3>Options <span style="font-size: 0.8rem; font-weight: 400; color: #ef4444;">(Mark the correct answer with the radio button)</span></h3>
                <div class="options-container" id="options-container-${qIndex}">
                    </div>
                
                <button type="button" class="add-option-btn" data-q-index="${qIndex}">
                    <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24" style="margin-right: 0.25rem;">
                        <path d="M12 5v14M5 12h14"></path>
                    </svg>
                    Add Option
                </button>
            `;
            
            questionsList.appendChild(card);

            // Event listener for removing question
            card.querySelector('.remove-question-btn').onclick = function() { removeQuestion(qIndex, card); };

            // Event listener for updating question text
            card.querySelector('.question-text-area').oninput = function(e) { 
                // Find the correct index for update since qIndex is immutable but array position changes
                const arrayIndex = Array.from(questionsList.children).indexOf(card);
                if(arrayIndex > -1) { questionsData[arrayIndex].title = e.target.value; }
            };

            // Event listener for Add Option button
            card.querySelector('.add-option-btn').onclick = function() {
                card.querySelector(`#options-container-${qIndex}`).appendChild(createOptionElement(qIndex));
            };
            
            // Add 4 default empty options for a new question
            if (existingData && existingData.options) {
                questionsData[qIndex].options = []; // Clear initial placeholder data if any
                existingData.options.forEach((opt, optIndex) => {
                    const isCorrect = existingData.correctAnswerIndex === optIndex;
                    card.querySelector(`#options-container-${qIndex}`).appendChild(createOptionElement(qIndex, opt.text, isCorrect));
                });
            } else {
                 card.querySelector(`#options-container-${qIndex}`).appendChild(createOptionElement(qIndex));
                 card.querySelector(`#options-container-${qIndex}`).appendChild(createOptionElement(qIndex));
                 card.querySelector(`#options-container-${qIndex}`).appendChild(createOptionElement(qIndex));
                 card.querySelector(`#options-container-${qIndex}`).appendChild(createOptionElement(qIndex));
            }

            calculateMarks();
            updateConsole(`Question ${qIndex + 1} added. Total questions: ${questionsData.length}.`);
            return card;
        }
        
        // Simplified approach to remove and re-index questions
        function removeQuestion(qIndex, questionCard) {
            const arrayIndex = Array.from(questionsList.children).indexOf(questionCard);
            if(arrayIndex > -1) {
                 questionsList.removeChild(questionCard);
                 questionsData.splice(arrayIndex, 1);
            }
            
            // Re-label remaining questions in the UI
            questionsList.querySelectorAll('.question-card').forEach((card, newIndex) => {
                card.querySelector('h2').textContent = `Question ${newIndex + 1}`;
                // Re-sync radio names (critical for functionality)
                card.querySelectorAll('.correct-answer-radio').forEach(radio => {
                    radio.name = `correct-option-${newIndex}`;
                });
            });

            calculateMarks();
            updateConsole(`Question removed. Total questions: ${questionsData.length}.`);
        }

        // --- Validation Logic (Skipped for brevity) ---
        function validateInputs() {
            // ... (validation logic remains the same)
            if (questionsData.length === 0) {
                return { message: 'At least one question must be added to the exam.' };
            }

            for (let i = 0; i < questionsData.length; i++) {
                const q = questionsData[i];
                if (!q.title.trim()) { return { message: `Question ${i + 1} text is required.` }; }
                if (q.options.length < 2) { return { message: `Question ${i + 1} must have at least two options.` }; }
                if (q.correctAnswerIndex === -1) { return { message: `The correct answer must be marked for Question ${i + 1}.` }; }

                for (let j = 0; j < q.options.length; j++) {
                    if (!q.options[j].text.trim()) { return { message: `Option ${String.fromCharCode(65 + j)} for Question ${i + 1} cannot be empty.` }; }
                }
            }
            return null; 
        }
        
        // --- Save and Finalize Logic ---
        saveFinishBtn.addEventListener('click', async () => {
            saveFinishBtn.disabled = true;
            saveFinishBtn.textContent = 'Validating and Saving...';
            updateConsole("Attempting to finalize and submit exam data...", 'info');

            const validationResult = validateInputs();
            if (validationResult) {
                updateConsole('SAVE FAILED: ' + validationResult.message, 'error');
                saveFinishBtn.disabled = false;
                saveFinishBtn.textContent = 'Finalize & Submit Exam';
                return;
            }

            try {
                const markPerQuestion = calculateMarks();
                const totalMinutes = (parseInt(examDurationHours.value) || 0) * 60 + (parseInt(examDurationMinutes.value) || 0);

                // 1. Update Exam Metadata (Duration and Type)
                const examDocRef = doc(db, 'exams', EXAM_ID);
                await setDoc(examDocRef, {
                    type: 'mcq',
                    duration: {
                        hours: parseInt(examDurationHours.value) || 0,
                        minutes: parseInt(examDurationMinutes.value) || 0,
                        totalMinutes: totalMinutes
                    },
                    totalMarks: TOTAL_EXAM_MARKS,
                    updatedAt: serverTimestamp()
                }, { merge: true });

                // 2. Save Questions (as subcollection documents)
                const questionsCollectionRef = collection(db, `exams/${EXAM_ID}/questions`);
                
                // Clear existing questions before writing (in case of edit/resubmit)
                const existingQuestions = await getDocs(questionsCollectionRef);
                existingQuestions.forEach((qDoc) => deleteDoc(qDoc.ref));

                for (let i = 0; i < questionsData.length; i++) {
                    const q = questionsData[i];
                    
                    const questionData = {
                        title: q.title,
                        options: q.options.map(opt => opt.text), 
                        correctAnswerIndex: q.correctAnswerIndex,
                        mark: markPerQuestion,
                        createdAt: serverTimestamp(),
                        updatedAt: serverTimestamp()
                    };

                    await addDoc(questionsCollectionRef, questionData);
                }

                hasQuestionsSaved = true; // Mark as successfully saved
                updateConsole(`SUCCESS: Exam (ID: ${EXAM_ID}) and ${questionsData.length} questions saved successfully. Redirecting...`, 'success');

                // 3. Redirect to the result/list page
                setTimeout(() => {
                    window.location.href = `../result.html?id=${EXAM_ID}`; 
                }, 2000);

            } catch (error) {
                console.error("Firebase save/update error:", error);
                updateConsole(`SAVE FAILED: ${error.message}. Check console and network.`, 'error');
                
                saveFinishBtn.disabled = false;
                saveFinishBtn.textContent = 'Finalize & Submit Exam';
            }
        });


        // --- Initialization and Event Binding ---
        backToAddNewLink.addEventListener('click', (e) => {
             e.preventDefault();
             attemptCleanup(); // Try to clean up before navigating away
             window.location.href = '../add_new.html';
        });

        function init() {
            if (!EXAM_ID) {
                updateConsole("ERROR: Missing Exam ID. Please start from the 'Add New Exam' page.", 'error');
                saveFinishBtn.disabled = true;
                return;
            }

            modeTitle.textContent = `Pareeksha MCQ Exam Setup (Exam ID: ${EXAM_ID.substring(0, 4)}...)`;
            addQuestionBtn.addEventListener('click', () => addQuestionCard());
            
            // Load existing data if editing or add default question if new
            loadExistingQuestions();
            
        }

        async function loadExistingQuestions() {
            const questionsRef = collection(db, `exams/${EXAM_ID}/questions`);
            const questionsSnap = await getDocs(questionsRef);

            if (!questionsSnap.empty) {
                questionsSnap.forEach(doc => {
                    // Reconstruct structure from saved data for editing
                    const data = doc.data();
                    const options = data.options.map((text, index) => ({
                        text: text,
                        isCorrect: data.correctAnswerIndex === index
                    }));
                    
                    addQuestionCard({
                        id: doc.id,
                        title: data.title,
                        options: options,
                        correctAnswerIndex: data.correctAnswerIndex
                    });
                });
                hasQuestionsSaved = true; // Mark as having questions
                updateConsole(`Loaded ${questionsSnap.docs.length} existing questions. Ready to edit.`, 'info');
            } else {
                 addQuestionCard(); // Start with one default question if empty
                 updateConsole(`Starting new MCQ exam setup.`, 'info');
            }
            calculateMarks();
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
