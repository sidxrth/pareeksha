<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title id="page-title">Pareeksha - Programming Exam</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&family=Fira+Code&display=swap" rel="stylesheet">
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/theme/material-darker.min.css">
    
    <script src="../face-api.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="module" src="../firebase-init.js"></script>

    <style>
        :root {
            --bg-color: #f8fafc;
            --card-bg: #ffffff;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --primary-accent: #334155;
            --primary-accent-hover: #1e293b;
            --border-color: #e2e8f0;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            line-height: 1.6;
            min-height: 100vh;
            /* Hide content until loading overlay is removed */
            overflow: hidden; 
        }

        h2 { font-size: 1.75rem; font-weight: 700; margin-bottom: 1.5rem; }
        h3 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; }

        /* --- Header --- */
        .header {
            background-color: var(--card-bg);
            padding: 1rem 2rem;
            box-shadow: var(--shadow-md);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 100;
        }
        .header-title { font-size: 1.25rem; font-weight: 600; }
        .timer-box {
            color: #ffffff;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: background-color 0.5s ease;
        }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        /* --- Layout --- */
        .container {
            max-width: 1500px;
            margin: 0 auto;
            padding: 6.5rem 2rem 2rem;
        }
        .grid-layout {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
        }
        @media (min-width: 1024px) {
            .grid-layout { grid-template-columns: repeat(5, 1fr); }
            .problem-section { grid-column: span 2; }
            .editor-section { grid-column: span 3; }
        }
        .io-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin-top: 1.5rem;
        }
        @media (min-width: 768px) {
            .io-grid { grid-template-columns: repeat(2, 1fr); }
        }

        /* MODIFIED: Camera View Box */
        .fixed-camera-view {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            width: 180px;
            height: 135px;
            background-color: #111827;
            border: 3px solid transparent; 
            border-radius: 0.75rem;
            z-index: 50;
            box-shadow: var(--shadow-lg);
            overflow: hidden;
            transition: border-color 0.3s ease;
        }
        #camera-feed {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        /* NEW: Proctoring Status Section */
        #proctor-section {
            position: fixed;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 60;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            background-color: #ffffff;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-md);
        }
        .status-ok { color: #10b981; } 
        .status-warn { color: #f59e0b; } 
        .status-alert { color: #ef4444; } 
        
        #live-status { /* In-camera status display */
            position: absolute; 
            top: 8px; 
            left: 8px; 
            background-color: #a0aec0; 
            color: white; 
            padding: 4px 8px; 
            border-radius: 4px; 
            font-size: 0.8rem; 
            font-weight: 600;
            z-index: 10;
        }

        /* --- Components --- */
        .card {
            background-color: var(--card-bg);
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
        }
        .card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-md);
        }
        .card.highlight {
            border-left: 5px solid var(--primary-accent);
        }
        .compile-btn, .finish-btn {
            width: 100%;
            background-color: var(--primary-accent);
            color: white;
            font-weight: 600;
            padding: 0.85rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 1rem;
            transition: background-color 0.2s ease;
        }
        .compile-btn:hover:not(:disabled) {
            background-color: var(--primary-accent-hover);
        }
        .compile-btn:disabled, .finish-btn:disabled {
             opacity: 0.5;
             cursor: not-allowed;
             box-shadow: none;
        }
        .finish-btn {
            background-color: #c53030;
        }
        .finish-btn:hover:not(:disabled) {
            background-color: #9b2c2c;
        }
        .header .finish-btn {
            width: auto;
            margin-top: 0;
            padding: 0.5rem 1rem;
        }

        .terminal {
            background-color: #1e293b;
            color: #e2e8f0;
            font-family: 'Fira Code', monospace;
            padding: 1rem;
            border-radius: 8px;
            min-height: 120px;
            border: 1px solid #334155;
            white-space: pre-wrap;
        }
        
        /* Specific Styles */
        .problem-description p, .problem-description ul { margin-bottom: 1rem; }
        .example-box {
            background-color: var(--bg-color);
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1.5rem;
            border: 1px solid var(--border-color);
        }
        .CodeMirror {
            border: 1px solid var(--border-color);
            height: 400px;
            font-family: 'Fira Code', monospace;
            font-size: 14px;
            border-radius: 8px;
        }
        /* Modal for Malpractice */
        .malpractice-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.8);
            color: white;
            display: none; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 3rem;
            font-weight: 700;
            z-index: 1000;
        }

        /* Submission Buffer Modal */
        .submission-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            display: none; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            font-size: 1.5rem;
            font-weight: 500;
            z-index: 1001;
            transition: opacity 0.3s ease;
        }
        .submission-overlay h3 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 2rem;
        }

        /* --- NEW LOADING OVERLAY STYLES --- */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Semi-transparent background (30% opacity) to obscure text */
            background-color: rgba(240, 244, 248, 0.9); 
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10000; /* Ensure it's above everything */
            color: var(--text-primary);
            font-weight: 600;
            font-size: 1.2rem;
        }

        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-top-color: var(--primary-accent);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 1.5rem;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    
    <div id="loading-overlay">
        <div class="loading-spinner"></div>
        <div id="loading-message">Setting up secure environment and fetching exam data...</div>
        <div class="text-sm text-gray-500 mt-2">Please wait while models load (Camera access pending).</div>
    </div>
    <div id="malpractice-modal" class="malpractice-modal">
        MALPRACTICE DETECTED!
        <div id="malpractice-reason" class="text-xl font-normal mt-4"></div>
        <div class="text-xl font-normal mt-4">Redirecting in 5 seconds...</div>
    </div>

    <div id="submission-overlay" class="submission-overlay">
        <h3>Submitting Exam...</h3>
        <div class="loading-spinner"></div>
        <div id="submission-status">Initializing submission.</div>
    </div>

    <header class="header">
        <div class="header-title" id="exam-title-header">Programming Challenge</div>
        <div class="header-controls">
            <button id="finish-btn" class="finish-btn" disabled>Finish Exam</button>
            <div class="timer-box" id="timer">--:--</div>
        </div>
    </header>

    <div class="fixed-camera-view" id="camera-container">
        <video id="camera-feed" autoplay muted></video>
        <div id="live-status">Loading...</div>
    </div>
    
    <div id="proctor-section" class="status-ok">Proctoring: Initializing...</div>

    <div class="container">
        <div class="grid-layout">
            
            <div class="problem-section card highlight">
                <h2 id="question-title">Loading Question...</h2>
                <div id="problem-description" class="problem-description">
                    <p>Fetching problem details from the server. Please wait...</p>
                </div>
                <div class="example-box">
                    <p><strong>Test Case Input:</strong></p>
                    <pre id="test-case-input-display">Loading test input...</pre>
                    <p class="mt-4"><strong>Expected Output:</strong></p>
                    <pre id="test-case-output-display">Loading expected output...</pre>
                </div>
            </div>

            <div class="editor-section">
                <div class="card">
                    <h3>Your Solution (Language: <span id="language-display"></span>)</h3>
                    <textarea id="code-editor"></textarea>
                </div>
                
                <button id="compile-btn" class="compile-btn" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" style="width: 1.25rem; height: 1.25rem;">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347a1.125 1.125 0 01-1.667-.985V5.653z" />
                    </svg>
                    Compile & Run (Simulated)
                </button>
                <div class="io-grid">
                    <div class="card" style="grid-column: span 2;">
                        <h3>Simulation Console</h3>
                        <pre id="output-terminal" class="terminal">Initializing...</pre>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <input type="hidden" id="user-email" value="">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>
    <script type="module">
        import { db, doc, getDoc, collection, getDocs, query, orderBy } from '../firebase-init.js'; 

        const editorArea = document.getElementById('code-editor');
        let editor = null; 

        // --- DOM Elements ---
        const cameraFeed = document.getElementById('camera-feed');
        const cameraContainer = document.getElementById('camera-container');
        const proctorSection = document.getElementById('proctor-section');
        const finishBtn = document.getElementById('finish-btn');
        const compileBtn = document.getElementById('compile-btn');
        const timerEl = document.getElementById('timer');
        const outputTerminal = document.getElementById('output-terminal');
        const liveStatusDiv = document.getElementById('live-status');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingMessageDiv = document.getElementById('loading-message');

        // Question Details
        const questionTitleEl = document.getElementById('question-title');
        const problemDescriptionEl = document.getElementById('problem-description');
        const testCaseInputEl = document.getElementById('test-case-input-display');
        const testCaseOutputEl = document.getElementById('test-case-output-display');
        const examTitleHeader = document.getElementById('exam-title-header');
        const languageDisplay = document.getElementById('language-display');

        // Submission elements
        const submissionOverlay = document.getElementById('submission-overlay');
        const submissionStatus = document.getElementById('submission-status');

        // --- GLOBAL STATE VARIABLES ---
        let userEmail = '';
        let examTypeSlug = ''; 
        let examId = '';        
        let language = 'clike'; 
        
        let faceMatcher = null; 
        let proctorViolationSeconds = 0;
        let proctorInterval = null;
        let isExamFinished = false; 
        let criticalViolation = false; 
        
        let timerInterval = null; 
        let timeLeft = 0; 
        let initialTime = 0;
        
        let isCorrect = false;
        let correctOutput = ''; 
        let testInputData = ''; 
        let userOutput = ''; // To store last run's output or error for AI context
        
        let questionTitle = '';
        let questionDescription = '';
        

        const REDIRECT_URL = '../../index.html';
        const MAX_VIOLATION_SECONDS = 15;
        const FACE_MATCH_THRESHOLD = 0.6; 
        
        // --- CodeMirror Initialization Function ---
        function setupCodeMirror(initialValue, codeLanguage) {
            const modeMap = {
                'C': 'text/x-csrc',
                'Java': 'text/x-java',
                'Python': 'python',
                'JavaScript': 'javascript',
            };

            const mode = modeMap[codeLanguage] || 'text/x-csrc';

            if (editor) editor.toTextArea();

            editor = CodeMirror.fromTextArea(editorArea, {
                lineNumbers: true,
                mode: mode,
                theme: "material-darker",
                matchBrackets: true,
                autoCloseBrackets: true,
                value: initialValue || "// Start coding here..."
            });
            language = mode; 
        }

        // --- DATA FETCHING (Primary Initialization Step) ---
        async function fetchExamData() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                userEmail = urlParams.get('email');
                examTypeSlug = urlParams.get('examType'); 
                examId = urlParams.get('id'); 

                if (!examId || !userEmail) {
                     throw new Error("Missing Exam ID or User Email in URL.");
                }

                loadingMessageDiv.textContent = "Fetching exam details...";

                const examRef = doc(db, 'exams', examId);
                const examSnap = await getDoc(examRef);

                if (!examSnap.exists()) {
                    throw new Error(`Exam ID ${examId} not found in Firebase.`);
                }

                const examData = examSnap.data();

                const questionsRef = collection(db, `exams/${examId}/questions`);
                const questionsQuery = query(questionsRef, orderBy('createdAt', 'asc')); 
                const questionsSnap = await getDocs(questionsQuery);

                let totalMinutes = 30;

                if (!questionsSnap.empty) {
                    const firstQuestion = questionsSnap.docs[0].data();
                    if (firstQuestion.duration && typeof firstQuestion.duration.totalMinutes === 'number' && firstQuestion.duration.totalMinutes > 0) {
                        totalMinutes = firstQuestion.duration.totalMinutes;
                        const hours = Math.floor(totalMinutes / 60);
                        const mins = totalMinutes % 60;
                        console.log(`Exam duration set to: ${hours}h ${mins}m (${totalMinutes} minutes)`);
                    } else {
                        console.warn('[WARNING] Invalid duration detected in question data, using default 30 minutes');
                    }
                } else {
                    throw new Error("No questions found for this exam.");
                }
                
                const qData = questionsSnap.docs[0].data();
                
                questionTitle = qData.title || "Untitled Question";
                questionDescription = qData.description || "<p>No description provided.</p>";

                questionTitleEl.textContent = questionTitle;
                problemDescriptionEl.innerHTML = questionDescription.replace(/\n/g, '<br>');
                examTitleHeader.textContent = examData.examName || "Programming Challenge";
                document.getElementById('page-title').textContent = `${examData.examName || 'Exam'} - Pareeksha`;
                
                setupCodeMirror(qData.templateCode || `// Write your ${qData.language || 'C'} code here\n`, qData.language); 
                languageDisplay.textContent = qData.language || 'C';

                const testCase = qData.testCases?.[0];
                if (testCase) {
                    testInputData = testCase.input;
                    correctOutput = testCase.expectedOutput;
                    testCaseInputEl.textContent = testInputData;
                    testCaseOutputEl.textContent = correctOutput;
                } else {
                    testInputData = 'N/A (No test input)';
                    correctOutput = 'N/A (No expected output)';
                    testCaseInputEl.textContent = 'No test input provided by instructor.';
                    testCaseOutputEl.textContent = 'No expected output provided by instructor.';
                }

                timeLeft = totalMinutes * 60;
                initialTime = totalMinutes * 60;

                // Initial display in HH:MM:SS
                const initialHours = Math.floor(timeLeft / 3600);
                const initialMins = Math.floor((timeLeft % 3600) / 60);
                const initialSecs = timeLeft % 60;
                timerEl.textContent = `${initialHours.toString().padStart(2, '0')}:${initialMins.toString().padStart(2, '0')}:${initialSecs.toString().padStart(2, '0')}`;
                
                compileBtn.disabled = false;
                finishBtn.disabled = false;
                outputTerminal.textContent = "Exam environment ready. Start coding!";
                
                await initProctoring();

            } catch (error) {
                console.error("CRITICAL Data Fetching Error:", error);
                loadingOverlay.style.backgroundColor = 'rgba(255, 0, 0, 0.9)';
                loadingOverlay.style.color = 'white';
                loadingOverlay.innerHTML = `
                    <div class="text-2xl font-bold">CRITICAL SETUP ERROR</div>
                    <div class="text-lg mt-2">${error.message || 'Failed to load exam data.'}</div>
                    <div class="text-sm mt-4">Please contact support.</div>
                `;
                outputTerminal.style.color = '#c53030';
                outputTerminal.textContent = `CRITICAL ERROR: Failed to load exam data. ${error.message}`;
                questionTitleEl.textContent = "Error Loading Exam";
                compileBtn.disabled = true;
                finishBtn.disabled = true;
                timerEl.textContent = "--:--";
            }
        }
        
        // --- WINDOW/TAB CLOSING AND SWITCHING HANDLERS (CRITICAL MALPRACTICE) ---
        
        function handleWindowBlur() {
            if (isExamFinished || criticalViolation) return;
            // CRITICAL: App switching results in termination
            malpracticeEnforcement("Exited/Switched Applications (Focus Loss Violation). Score set to 0.", true);
        }

        function handleWindowFocus() {
            if (isExamFinished || criticalViolation) return;
            proctorSection.textContent = "Proctoring: Active";
            proctorSection.className = 'status-ok'; 
            cameraContainer.style.borderColor = '#10b981';
        }

        function handleFullScreenChange() {
            if (!document.fullscreenElement && !isExamFinished) {
                malpracticeEnforcement("Exited Full-Screen Mode. Exam is terminated.");
            }
        }

        function handleBeforeUnload(e) {
            if (!isExamFinished) {
                // If user closes window/tab, force app quit
                if (window.electronAPI && window.electronAPI.forceQuit) {
                    window.electronAPI.forceQuit();
                }
                // Fallback for non-Electron
                e.preventDefault();
                e.returnValue = 'WARNING! Exiting the exam page without clicking "Finish Exam" will be logged as a proctoring violation and may invalidate your attempt.';
                return 'WARNING! Exiting the exam page without clicking "Finish Exam" will be logged as a proctoring violation and may invalidate your attempt.';
            }
        }

        // --- MODIFIED MALPRACTICE ENFORCEMENT ---
        function malpracticeEnforcement(reason, isCriticalSetup = false) {
            if (isExamFinished) return;
            isExamFinished = true; 
            criticalViolation = true; // Score must be 0.
            
            window.removeEventListener('beforeunload', handleBeforeUnload);
            window.removeEventListener('blur', handleWindowBlur);
            window.removeEventListener('focus', handleWindowFocus);
            document.removeEventListener('fullscreenchange', handleFullScreenChange);
            
            clearInterval(timerInterval);
            clearInterval(proctorInterval);
            compileBtn.disabled = true;
            finishBtn.disabled = true;

            try {
                if (cameraFeed.srcObject && cameraFeed.srcObject.getTracks) {
                    cameraFeed.srcObject.getTracks().forEach(track => track.stop());
                }
            } catch (e) {
                console.error("Could not stop camera tracks:", e);
            }
            
            const alertMessage = isCriticalSetup 
                ? `CRITICAL ERROR: Exam policy not followed (Setup Failure).\nReason: ${reason}`
                : `EXAM TERMINATED: Malpractice Detected! Your exam is now locked and score set to 0.\nReason: ${reason}`;

            alert(alertMessage); 

            // CRITICAL: Use the exposed IPC function to terminate the whole Electron application
            if (window.electronAPI && window.electronAPI.forceQuit) {
                window.electronAPI.forceQuit();
            } else {
                // Fallback for non-Electron
                window.location.href = `complete.html?score=0&exam=${examTypeSlug}&email=${userEmail}`;
            }
        }
        
        // --- Proctoring and Timer Logic (Unchanged from previous step) ---
        async function initProctoring() {
            loadingMessageDiv.textContent = "Loading security models (Biometric Setup)...";
            try {
                if (!userEmail) return;

                proctorSection.textContent = "Proctoring: Loading models...";
                liveStatusDiv.textContent = "Loading...";

                await Promise.all([
                    faceapi.nets.ssdMobilenetv1.loadFromUri('../models'),
                    faceapi.nets.tinyFaceDetector.loadFromUri('../models'), 
                    faceapi.nets.faceRecognitionNet.loadFromUri('../models'),
                    faceapi.nets.faceLandmark68Net.loadFromUri('../models'),
                    faceapi.nets.ageGenderNet.loadFromUri('../models'), 
                    faceapi.nets.faceExpressionNet.loadFromUri('../models') 
                ]);

                loadingMessageDiv.textContent = "Verifying biometric profile...";
                proctorSection.textContent = "Proctoring: Fetching profile...";
                const response = await fetch(`http://localhost:3000/get-user-face-data?email=${encodeURIComponent(userEmail)}`);
                
                if (!response.ok) {
                    const errorJson = await response.json().catch(() => ({ message: `HTTP Error ${response.status}` }));
                    throw new Error(errorJson.message || `Server failed to fetch profile: ${response.status} ${response.statusText}`);
                }

                const data = await response.json();
                
                if (!data.face_descriptor) {
                    throw new Error('User face data found but descriptor is empty. Please enroll again.');
                }
                
                const faceDescriptor = JSON.parse(data.face_descriptor);
                
                const labeledDescriptors = new faceapi.LabeledFaceDescriptors(
                    userEmail, 
                    faceDescriptor.map(d => new Float32Array(d))
                );
                faceMatcher = new faceapi.FaceMatcher([labeledDescriptors], FACE_MATCH_THRESHOLD);
                
                await startCameraAndTimer();

            } catch (err) {
                console.error("CRITICAL PROCTORING SETUP FAILURE:", err);
                throw new Error(`Proctoring setup failed: ${err.message}.`);
            }
        }

        async function startCameraAndTimer() {
            loadingMessageDiv.textContent = "Accessing Camera...";
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                cameraFeed.srcObject = stream;
                
                return new Promise(resolve => {
                    cameraFeed.addEventListener('loadeddata', () => {
                        proctorSection.textContent = "Proctoring: Active";
                        proctorSection.className = 'status-ok';
                        proctorInterval = setInterval(proctorLoop, 500);
                        if (timeLeft > 0) startTimerLogic(); 
                        
                        loadingOverlay.style.display = 'none';
                        document.body.style.overflow = 'auto';
                        resolve();
                    });
                });
            } catch (err) {
                console.error("Camera Access Denied:", err);
                throw new Error("Camera access denied. Cannot proceed with the exam.");
            }
        }
        
        async function proctorLoop() {
            if (!faceMatcher || isExamFinished || criticalViolation) return;

            let violation = false;
            let violationReason = "";
            let detectionOptions = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.5 });
            
            const fullDetections = await faceapi.detectAllFaces(cameraFeed, detectionOptions)
                .withFaceLandmarks()
                .withFaceDescriptors();

            
            if (!fullDetections || fullDetections.length === 0) { 
                violation = true;
                violationReason = "NO FACE DETECTED in camera view. (Code: 1)";
            } else if (fullDetections.length > 1) {
                violation = true;
                violationReason = `MULTIPLE FACES (${fullDetections.length}) detected. (Code: 2)`;
            } else { 
                const bestMatch = faceMatcher.findBestMatch(fullDetections[0].descriptor);
                
                if (bestMatch.label !== userEmail) {
                    violation = true;
                    violationReason = `UNAUTHORIZED FACE detected. (Code: 3)`;
                } else {
                    proctorViolationSeconds = Math.max(0, proctorViolationSeconds - 0.5); 
                    
                    liveStatusDiv.style.backgroundColor = '#10b981'; 
                    liveStatusDiv.textContent = 'LIVE';
                    cameraContainer.style.borderColor = '#10b981'; 
                    proctorSection.textContent = "Proctoring: Face Verified (OK)";
                    proctorSection.className = 'status-ok'; 
                }
            }
            
            if (violation) {
                proctorViolationSeconds += 0.5; 
                
                liveStatusDiv.style.backgroundColor = '#ef4444'; 
                liveStatusDiv.textContent = 'WARNING';
                cameraContainer.style.borderColor = '#ef4444'; 
                
                proctorSection.textContent = `WARNING: ${violationReason} (${Math.ceil(proctorViolationSeconds)}/${MAX_VIOLATION_SECONDS}s)`;
                proctorSection.className = 'status-alert'; 
            }

            if (proctorViolationSeconds >= MAX_VIOLATION_SECONDS) {
                malpracticeEnforcement(violationReason);
            }
        }
        
        function startTimerLogic() {
            const colors = ["#22c55e", "#16a34a", "#15803d", "#166534", "#14532d", "#ef4444"];
            timerEl.style.backgroundColor = colors[0];
            
            timerInterval = setInterval(() => {
                if (isExamFinished) {
                    clearInterval(timerInterval);
                    return;
                }
                timeLeft--;
                
                const hours = Math.floor(timeLeft / 3600);
                const minutes = Math.floor((timeLeft % 3600) / 60);
                const seconds = timeLeft % 60;
                timerEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

                const timePassed = initialTime - timeLeft;
                const colorIndex = Math.floor(timePassed / (5 * 60));

                if (timeLeft <= 5 * 60 && timeLeft > 0) {
                    timerEl.style.backgroundColor = colors[5]; 
                } else if (timeLeft > 0) {
                    timerEl.style.backgroundColor = colors[Math.min(colorIndex, colors.length - 2)];
                }

                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    malpracticeEnforcement("Time limit reached. Exam submission auto-locked.", true);
                }
            }, 1000);
        }

        compileBtn.addEventListener('click', async () => {
            if (isExamFinished) return; 

            const code = editor.getValue();
            const inputData = testCaseInputEl.textContent.trim();
            const language = languageDisplay.textContent;
            const expectedOutput = correctOutput.trim();

            // Clear and set initial terminal appearance
            outputTerminal.textContent = `> RUNNING CODE...
> Input: ${inputData}
---`;
            outputTerminal.style.color = '#90cdf4';
            compileBtn.disabled = true;

            try {
                const response = await fetch('http://localhost:3000/compile-and-run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        userCode: code, 
                        language: language,
                        inputData: inputData
                    })
                });

                const data = await response.json();
                
                if (response.ok) {
                    userOutput = data.output.trim(); // Capture clean output
                    
                    if (userOutput === expectedOutput) {
                        outputTerminal.style.color = '#10b981';
                        outputTerminal.textContent = `> EXECUTION SUCCESS (EXIT CODE 0)
---
> Input Sent: ${inputData.substring(0, 50)}...
> Actual Output: ${userOutput}
---
VERIFICATION: **Test Case PASSED.** Score: 50.`;
                        isCorrect = true; 
                    } else {
                        outputTerminal.style.color = '#f59e0b';
                        outputTerminal.textContent = `> EXECUTION SUCCESS (EXIT CODE 0)
---
> Input Sent: ${inputData.substring(0, 50)}...
> Expected: ${expectedOutput}
> Actual Output: ${userOutput}
---
VERIFICATION: **Test Case FAILED.** Score determined by AI (1-49 marks).`;
                        isCorrect = false;
                    }

                } else {
                    outputTerminal.style.color = '#ef4444'; 
                    
                    // Format terminal error output
                    const status = data.status;
                    let errorDetails = (data.output || data.error || 'Unknown Error').trim();
                    
                    // Capture the full error for AI context, truncate only for display
                    userOutput = errorDetails;
                    if(errorDetails.length > 500) {
                          errorDetails = errorDetails.substring(0, 500) + "\n... (Error output truncated)";
                    }

                    outputTerminal.textContent = `> ${status} DETECTED
---
${errorDetails}`;
                    isCorrect = false;

                }
                
            } catch (error) {
                outputTerminal.style.color = '#f56565';
                outputTerminal.textContent = `> CRITICAL CONNECTION FAILURE
---
> Could not connect to backend execution environment. Server down?
> Details: ${error.message}`;
                userOutput = `Connection error: ${error.message}`; // Capture connection error
                isCorrect = false;
            } finally {
                 compileBtn.disabled = false;
            }
        });

        finishBtn.addEventListener('click', async () => {
            if (isExamFinished) return;

            isExamFinished = true; 

            submissionOverlay.style.display = 'flex';

            clearInterval(timerInterval);
            clearInterval(proctorInterval);
            compileBtn.disabled = true;
            finishBtn.disabled = true;

            try {
                if (cameraFeed.srcObject && cameraFeed.srcObject.getTracks) {
                    cameraFeed.srcObject.getTracks().forEach(track => track.stop());
                }
            } catch (e) {
                console.error("Could not stop camera tracks:", e);
            }
            
            window.removeEventListener('beforeunload', handleBeforeUnload);

            const statusMessages = [
                "Preparing your submission...", "Checking your output...", "Evaluating your answer...", 
                "Calculating your mark...", "Verifying your email and records...", "Finalizing submission..."
            ];
            const code = editor.getValue();
            const email = userEmail; 
            const exam = examTypeSlug;
            
            const finalIsCorrect = isCorrect; 

            const submittedQuestion = {
                title: questionTitle,
                description: problemDescriptionEl.innerHTML, 
                language: languageDisplay.textContent,
                test_input: testInputData,
                expected_output: correctOutput,
                actual_output: userOutput
            };

            try {
                const showStatus = async (message, delay = 500) => {
                    submissionStatus.textContent = message;
                    await new Promise(resolve => setTimeout(resolve, delay));
                };

                await showStatus(statusMessages[0]);
                await showStatus(statusMessages[1], 800);
                await showStatus(statusMessages[2], 800);
                
                await showStatus(statusMessages[3], 100);
                const responsePromise = fetch('http://localhost:3000/submit-exam', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        email, 
                        exam, 
                        examFullName: examTitleHeader.textContent,
                        userCode: code, 
                        timeRemaining: timeLeft, 
                        isCorrect: finalIsCorrect, 
                        submittedQuestion,
                        examId 
                    })
                });

                const [response] = await Promise.all([
                    responsePromise,
                    showStatus(statusMessages[4], 1500).then(() => showStatus(statusMessages[5], 1000))
                ]);

                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.message || 'Server failed to process submission.');
                }
                
                if (window.electronAPI && window.electronAPI.exitFullScreen) {
                    window.electronAPI.exitFullScreen();
                }
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }

                submissionStatus.textContent = "Submission successful! Redirecting...";
                setTimeout(() => {
                    window.location.href = `complete.html?score=${data.score}&exam=${exam}&email=${email}`;
                }, 500); 

            } catch (error) {
                console.error("Submission Failure:", error);
                submissionOverlay.style.display = 'none'; 
                alert(`Submission Error: ${error.message}. Please try clicking 'Finish Exam' again.`);
                
                compileBtn.disabled = false;
                finishBtn.disabled = false;
                startTimerLogic(); 
                proctorInterval = setInterval(proctorLoop, 500);
                isExamFinished = false; 
                window.addEventListener('beforeunload', handleBeforeUnload); 
            }
        });

        // --- EXECUTION (Initialization) ---
        document.addEventListener('DOMContentLoaded', () => {
            const loadScript = (src) => {
                return new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = src;
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
            };
            
            loadingOverlay.style.display = 'flex';

            Promise.all([
                loadScript("https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/clike/clike.min.js"),
                loadScript("https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/mode/python/python.min.js")
            ]).then(fetchExamData).catch(error => {
                console.error("Failed to load CodeMirror modes:", error);
            });

            // 1. ADD WINDOW FOCUS/BLUR LISTENERS
            window.addEventListener('blur', handleWindowBlur);
            window.addEventListener('focus', handleWindowFocus);
            
            // 2. NEW: ADD KEYDOWN LISTENER FOR SHORTCUTS (MODIFIED FOR PASTE)
            document.addEventListener('keydown', (e) => {
                 const isCtrlKey = e.ctrlKey || e.metaKey; // Handles Ctrl and Cmd (Mac)
                 
                 // Block Copy (C) and Cut (X) but ALLOW Paste (V)
                 const isBlockingShortcut = ['c', 'x'].includes(e.key.toLowerCase());
                 
                 if (isCtrlKey && isBlockingShortcut) {
                     e.preventDefault(); 
                     e.stopPropagation();
                     return; 
                 }
                 
                 // Rule 2: DevTools access still results in malpractice termination
                 if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && (e.key === 'I' || e.key === 'J'))) {
                      e.preventDefault();
                      e.stopPropagation();
                      malpracticeEnforcement(`DevTools access attempt detected (${e.key}). Score set to 0.`);
                 }
            });
            
            // 3. ADD GENERIC CLIPBOARD BLOCKING LISTENERS (Paste listener removed, Copy/Cut retained)
            document.addEventListener('copy', (e) => e.preventDefault());
            document.addEventListener('cut', (e) => e.preventDefault());
            // document.addEventListener('paste', (e) => e.preventDefault()); // <-- REMOVED to enable context menu paste

            if (window.electronAPI && window.electronAPI.enterFullScreen) {
                window.electronAPI.enterFullScreen();
            }

            document.addEventListener('fullscreenchange', handleFullScreenChange);
            window.addEventListener('beforeunload', handleBeforeUnload);
        });
    </script>
</body>
</html>